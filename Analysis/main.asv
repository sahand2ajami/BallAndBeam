% Pipeline to process the raw experimental data
clc; clear; close all;
format compact

%% Convert .csv files to .mat format

start = 3; %Starting folder from 3, ignoring '.' and '..' in the directory
num_participants = 1;
stop = start + (num_participants - 1); %final folder depends on the number of participants

n_phase = 3; % this is the number of experiment phases that the participants had

% This is where each participants' data are stored for this project
cd ('C:\Users\s2ajami\OneDrive - University of Waterloo\BallAndBeam-project\BallAndBeam\data\pilot')

% This function loops in every participant's folder and makes a .mat copy
% of their .csv data 
% Input: start and stop numbers for looping the participants' folders
csv2mat(start, stop, n_phase)

%% Take all .mat files and integrate them in a structure file SubjectData

SubjectData = mat2struct(start, stop, n_phase);

% Get the field names
fieldNames = fieldnames(SubjectData);
% Count the number of which is the number of fields
n_participants = numel(fieldNames);

Metrics = struct();
%% Cleaning the time from the data

%% Ball movement analysis
% Here we see how long did ball stayed on target

% ball_data = struct();
% target_data = struct(); 

% Get the field names
participants_list = fieldnames(SubjectData);

% These need to be checked before the final version of the code. 
threshold = 0.1;
occluder_boundary = 0.1;

% variables to calculate mean and std of different metrics.


% This loops in participants
for i = 1:size(participants_list, 1)
    phases = SubjectData.(participants_list{i});
    phases_list = fieldnames(phases);

    % This loops in the phases
    for j = 1:size(phases_list, 1)
        trials = SubjectData.(participants_list{i}).(phases_list{j});
        trials_list = fieldnames(trials);
        % This loops in the trials
        for k = 1:size(trials_list, 1)

            % Extract the trajectory of the ball
            ball_trajectory = SubjectData.(participants_list{i}).(phases_list{j}).(trials_list{k}).ball.X;
            
            % Extract the time of each trial
            time_array = SubjectData.(participants_list{i}).(phases_list{j}).(trials_list{k}).time.time;
            time_array = time_array - time_array(1);
            
            %%% Ball on target overall %%%
            % Calculate the overall time that the ball stayed on the target
            % by checking the difference between the trajctory of the ball
            % and the target
            ball_data = timetable(SubjectData.(participants_list{i}).(phases_list{j}).(trials_list{k}).ball.X, 'VariableNames', {'X'}, 'RowTimes', seconds(time_array));
            target_data = timetable(SubjectData.(participants_list{i}).(phases_list{j}).(trials_list{k}).target.X, 'VariableNames', {'X'}, 'RowTimes', seconds(time_array));
            
            difference = ball_data.X - target_data.X;
            ball_on_target = ball_data((abs(difference) < threshold), :);

            ball_on_target_time = seconds(ball_on_target.Time(end) - ball_on_target.Time(1));
            ball_on_target_time_meanstd(k, 1) = ball_on_target_time;
            
            % Save the over all time trial by trial
            Metrics.(phases_list{j}).(participants_list{i}).BallOnTargetTime.Trials.(trials_list{k}) = ball_on_target_time;

            %%% Ball on target (behind the occluder version) %%%
            % Calculate the overall time that the ball stayed on the target
            % behind the occluder
            % by checking the difference between the trajctory of the ball
            % and the target behind the occluder
            occluder_data = timetable(SubjectData.(participants_list{i}).(phases_list{j}).(trials_list{k}).occluder.X, 'VariableNames', {'X'}, 'RowTimes', seconds(time_array));
            occluder_data = mean(occluder_data.X);

            difference = ball_on_target.X - occluder_data;
            ball_on_target_behind_occluder = ball_on_target((abs(difference) < occluder_boundary), :);
            if isempty(ball_on_target_behind_occluder)
                ball_on_target_behind_occluder_time = 0;
                ball_on_target_behind_occluder_time_meanstd_trialwise(k, 1) = 0;
            else
                ball_on_target_behind_occluder_time = seconds(ball_on_target_behind_occluder.Time(end) - ball_on_target_behind_occluder.Time(1));
                ball_on_target_behind_occluder_time_meanstd_trialwise(k, 1) = ball_on_target_behind_occluder_time;
            end

            % Save the over all time trial by trial
            Metrics.(phases_list{j}).(participants_list{i}).BallOnTargetBehindOccluderTime.Trials.(trials_list{k}) = ball_on_target_behind_occluder_time;
        
            %%% Smoothness metric %%%
            % Extract the hand trajectories
            left_hand = SubjectData.(participants_list{i}).(phases_list{j}).(trials_list{k}).left_hand;
            right_hand = SubjectData.(participants_list{i}).(phases_list{j}).(trials_list{k}).right_hand;
            
            % Save the trajectory into time tables
            left_hand_timetable = timetable(left_hand.X, left_hand.Y, left_hand.Z, 'VariableNames', {'X', 'Y', 'Z'}, 'RowTimes', seconds(time_array));
            right_hand_timetable = timetable(right_hand.X, right_hand.Y, right_hand.Z, 'VariableNames', {'X', 'Y', 'Z'}, 'RowTimes', seconds(time_array));
            
            % Save the trajectories into Metrics variable
            Metrics.(phases_list{j}).(participants_list{i}).LeftHand.Trials.(trials_list{k}) = left_hand_timetable;
            Metrics.(phases_list{j}).(participants_list{i}).RightHand.Trials.(trials_list{k}) = right_hand_timetable;
            
            % Analyze the left hand trajectory and extract speed and jerk
            % metrics for smoothness
            [jerk_metric_left, speed_metric_left] = traj_analysis(left_hand_timetable);
            
            % Save the left hand smoothness metrics into Metrics variable
            Metrics.(phases_list{j}).(participants_list{i}).Smoothness.jerk.left.Trials.(trials_list{k}) = jerk_metric_left;
            Metrics.(phases_list{j}).(participants_list{i}).Smoothness.speed.left.Trials.(trials_list{k}) = speed_metric_left;
            
            % Append the left hand smoothness metrics into _meanstd
            % variable which is used later to calculate the mean and std of
            % each participant over their trials
            jerk_metric_left_meanstd_trialwise(k,1) = jerk_metric_left;
            speed_metric_left_meanstd_trialwise(k,1) = speed_metric_left;

            % Analyze the right hand trajectory and extract speed and jerk
            % metrics for smoothness
            [jerk_metric_right, speed_metric_right] = traj_analysis(right_hand_timetable);

            % Save the right hand smoothness metrics into Metrics variable
            Metrics.(phases_list{j}).(participants_list{i}).Smoothness.jerk.right.Trials.(trials_list{k}) = jerk_metric_right;
            Metrics.(phases_list{j}).(participants_list{i}).Smoothness.speed.right.Trials.(trials_list{k}) = speed_metric_right;
            
            % Append the right hand smoothness into _meanstd variable which
            % is used later to calculate the mean and std of each
            % participant over their trials
            jerk_metric_right_meanstd_trialwise(k,1) = jerk_metric_right;
            speed_metric_right_meanstd_trialwise(k,1) = speed_metric_right;

            % Combine the two hands smoothness metrics by calculating
            % different means
            [arithmetic_mean, geometric_mean, rms, harmonic_mean, vector_sum] ...
                = smoothness_combinator(jerk_metric_left, jerk_metric_right);
            Metrics.(phases_list{j}).(participants_list{i}).Smoothness.jerk.combined.arithmetic_mean.Trials.(trials_list{k}) = arithmetic_mean;
            Metrics.(phases_list{j}).(participants_list{i}).Smoothness.jerk.combined.geometric_mean.Trials.(trials_list{k}) = geometric_mean;
            Metrics.(phases_list{j}).(participants_list{i}).Smoothness.jerk.combined.rms.Trials.(trials_list{k}) = rms;
            Metrics.(phases_list{j}).(participants_list{i}).Smoothness.jerk.combined.harmonic.Trials.(trials_list{k}) = harmonic_mean;
            Metrics.(phases_list{j}).(participants_list{i}).Smoothness.jerk.combined.vector_sum.Trials.(trials_list{k}) = vector_sum;
            
            [arithmetic_mean, geometric_mean, rms, harmonic_mean, vector_sum] ...
                = smoothness_combinator(speed_metric_left, speed_metric_right);
            Metrics.(phases_list{j}).(participants_list{i}).Smoothness.speed.combined.arithmetic_mean.Trials.(trials_list{k}) = arithmetic_mean;
            Metrics.(phases_list{j}).(participants_list{i}).Smoothness.speed.combined.geometric_mean.Trials.(trials_list{k}) = geometric_mean;
            Metrics.(phases_list{j}).(participants_list{i}).Smoothness.speed.combined.rms.Trials.(trials_list{k}) = rms;
            Metrics.(phases_list{j}).(participants_list{i}).Smoothness.speed.combined.harmonic.Trials.(trials_list{k}) = harmonic_mean;
            Metrics.(phases_list{j}).(participants_list{i}).Smoothness.speed.combined.vector_sum.Trials.(trials_list{k}) = vector_sum;
        end

        %%% Save the mean and std of over the trials from each participant
        % The time that ball stays on the target
        Metrics.(phases_list{j}).(participants_list{i}).BallOnTargetTime.arrayovertrials = ball_on_target_time_meanstd;
        Metrics.(phases_list{j}).(participants_list{i}).BallOnTargetTime.mean = mean(ball_on_target_time_meanstd);
        Metrics.(phases_list{j}).(participants_list{i}).BallOnTargetTime.std = std(ball_on_target_time_meanstd);

        % The time that ball stays on the target while behind the occluder
        Metrics.(phases_list{j}).(participants_list{i}).BallOnTargetBehindOccluderTime.arrayovertrials = ball_on_target_behind_occluder_time_meanstd_trialwise;
        Metrics.(phases_list{j}).(participants_list{i}).BallOnTargetBehindOccluderTime.mean = mean(ball_on_target_behind_occluder_time_meanstd_trialwise);
        Metrics.(phases_list{j}).(participants_list{i}).BallOnTargetBehindOccluderTime.std = std(ball_on_target_behind_occluder_time_meanstd_trialwise);
        Metrics.(phases_list{j}).(participants_list{i}).BallOnTargetBehindOccluderTime.median = median(ball_on_target_behind_occluder_time_meanstd_trialwise);
        
        % jerk metric of the left hand
        Metrics.(phases_list{j}).(participants_list{i}).Smoothness.jerk.left.arrayovertrials = jerk_metric_left_meanstd_trialwise;
        Metrics.(phases_list{j}).(participants_list{i}).Smoothness.jerk.left.mean = mean(jerk_metric_left_meanstd_trialwise);
        Metrics.(phases_list{j}).(participants_list{i}).Smoothness.jerk.left.std = std(jerk_metric_left_meanstd_trialwise);

        % Jerk metric of the right hand
        Metrics.(phases_list{j}).(participants_list{i}).Smoothness.jerk.right.arrayovertrials = jerk_metric_right_meanstd_trialwise;
        Metrics.(phases_list{j}).(participants_list{i}).Smoothness.jerk.right.mean = mean(jerk_metric_right_meanstd_trialwise);
        Metrics.(phases_list{j}).(participants_list{i}).Smoothness.jerk.right.std = std(jerk_metric_right_meanstd_trialwise);

        % Speed metric of the left hand
        Metrics.(phases_list{j}).(participants_list{i}).Smoothness.speed.left.arrayovertrials = speed_metric_left_meanstd_trialwise;
        Metrics.(phases_list{j}).(participants_list{i}).Smoothness.speed.left.mean = mean(speed_metric_left_meanstd_trialwise);
        Metrics.(phases_list{j}).(participants_list{i}).Smoothness.speed.left.std = std(speed_metric_left_meanstd_trialwise);

        % Speed metric of the right hand
        Metrics.(phases_list{j}).(participants_list{i}).Smoothness.speed.right.arrayovertrials = speed_metric_right_meanstd_trialwise;
        Metrics.(phases_list{j}).(participants_list{i}).Smoothness.speed.right.mean = mean(speed_metric_right_meanstd_trialwise);
        Metrics.(phases_list{j}).(participants_list{i}).Smoothness.speed.right.std = std(speed_metric_right_meanstd_trialwise);

        % Append the mean of each metric into an array so that they can be
        % used in calculation of the mean across participants
        ball_on_target_time_mean_participantwise(i, 1) = Metrics.(phases_list{j}).(participants_list{i}).BallOnTargetTime.mean;
        ball_on_target_behind_occluder_time_mean_participantwise(i, 1) = Metrics.(phases_list{j}).(participants_list{i}).BallOnTargetBehindOccluderTime.mean;
        jerk_metric_left_mean_participantwise(i, 1) = Metrics.(phases_list{j}).(participants_list{i}).Smoothness.jerk.left.mean;
        jerk_metric_right_mean_participantwise(i, 1) = Metrics.(phases_list{j}).(participants_list{i}).Smoothness.jerk.right.mean;
        speed_metric_left_mean_participantwise(i, 1) = Metrics.(phases_list{j}).(participants_list{i}).Smoothness.speed.left.mean;
        speed_metric_right_mean_participantwise(i, 1) = Metrics.(phases_list{j}).(participants_list{i}).Smoothness.speed.right.mean;
    end

    Metrics_overparticipants.(phases_list{j}).BallOnTargetTime.array = ball_on_target_time_mean_participantwise;
    Metrics_overparticipants.(phases_list{j}).BallOnTargetTime.mean = mean(ball_on_target_time_mean_participantwise);
    Metrics_overparticipants.(phases_list{j}).BallOnTargetTime.std = std(ball_on_target_time_mean_participantwise);

    Metrics_overparticipants.(phases_list{j}).BallOnTargetBehindOccluderTime.array = ball_on_target_behind_occluder_time_mean_participantwise;
    Metrics_overparticipants.(phases_list{j}).BallOnTargetBehindOccluderTime.mean = mean(ball_on_target_behind_occluder_time_mean_participantwise);
    Metrics_overparticipants.(phases_list{j}).BallOnTargetBehindOccluderTime.std = std(ball_on_target_behind_occluder_time_mean_participantwise);

    Metrics_overparticipants.(phases_list{j}).Smoothness.jerk.left.array = jerk_metric_left_mean_participantwise;
    Metrics_overparticipants.(phases_list{j}).Smoothness.jerk.left.mean = mean(jerk_metric_left_mean_participantwise);
    Metrics_overparticipants.(phases_list{j}).Smoothness.jerk.left.std = std(jerk_metric_left_mean_participantwise);

    Metrics_overparticipants.(phases_list{j}).Smoothness.jerk.right.array = jerk_metric_right_mean_participantwise;
    Metrics_overparticipants.(phases_list{j}).Smoothness.jerk.right.mean = mean(jerk_metric_right_mean_participantwise);
    Metrics_overparticipants.(phases_list{j}).Smoothness.jerk.right.std = std(jerk_metric_right_mean_participantwise);

    Metrics_overparticipants.(phases_list{j}).Smoothness.speed.left.array = speed_metric_left_mean_participantwise;
    Metrics_overparticipants.(phases_list{j}).Smoothness.speed.left.mean = mean(speed_metric_left_mean_participantwise);
    Metrics_overparticipants.(phases_list{j}).Smoothness.speed.left.std = std(speed_metric_left_mean_participantwise);

    Metrics_overparticipants.(phases_list{j}).Smoothness.speed.right.array = speed_metric_right_mean_participantwise;
    Metrics_overparticipants.(phases_list{j}).Smoothness.speed.right.mean = mean(speed_metric_right_mean_participantwise);
    Metrics_overparticipants.(phases_list{j}).Smoothness.speed.right.std = std(speed_metric_right_mean_participantwise);


end

my_boxchart = my_boxplot(Metrics_overparticipants.(phases_list{1}).Smoothness.speed.right.mean, ...
    Metrics_overparticipants.(phases_list{2}).Smoothness.speed.right.mean, ...
    2, 'Linux Libertine G', 9, 'kir1', 'kir2', [0, 10])
